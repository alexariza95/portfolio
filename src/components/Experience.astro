---
const experiences = [
  {
    role: "Full-Stack Engineer",
    company: "GT Motive Spain",
    period: "Oct 2023 — Present",
    description: "Building and scaling an Azure microservices platform for automotive repair operations, with a strong focus on clean boundaries (Clean Architecture/SOLID) and reliable delivery through Azure DevOps CI/CD.",
    technologies: ["Azure", ".NET Core", "Angular", "Microservices"]
  },
  {
    role: "Backend Engineer",
    company: "AML Analytics",
    period: "Jan 2023 — Oct 2023",
    description: "Fortified codebase with comprehensive unit tests using AutoFixture. Successfully migrated applications from .NET Framework 4.8 to .NET 6, improving performance and maintainability.",
    technologies: [".NET 6", "C#", "AutoFixture", "Migration"]
  },
  {
    role: "Full-Stack Engineer",
    company: "atwork.",
    period: "Jul 2022 — Jan 2023",
    description: "Delivered production features in a mature app using Onion Architecture and Atomic Design, backed by a full testing strategy (unit, integration, and E2E) to keep releases stable.",
    technologies: ["Angular", "Onion Arch", "Atomic Design", "Entity Framework"]
  },
  {
    role: "Full-Stack Engineer",
    company: "Pam Learning",
    period: "Oct 2021 — Jul 2022",
    description: "Improved maintainability with clean code and Hexagonal Architecture practices while upgrading the stack (.NET 5→.NET 6) and migrating the frontend from vanilla TypeScript to Razor Pages.",
    technologies: [".NET 6", "Razor Pages", "TypeScript", "Hexagonal Arch"]
  },
  {
    role: "Full-Stack Developer - Intern",
    company: "CTI SL",
    period: "Nov 2020 — Sep 2021",
    description: "Maintained and extended a legacy VB/jQuery web app, and built strong SQL Server expertise by implementing complex stored procedures and functions to support core business logic.",
    technologies: ["Visual Basic", ".NET Framework", "jQuery", "SQL Server"]
  }
];
---

<section id="experience" class="bg-dark text-white relative">
  <div class="scroll-container h-screen w-full overflow-hidden flex flex-col justify-center items-start relative">
      
      <!-- Static Header Overlay -->
      <div class="absolute top-12 left-6 md:left-20 z-20 pointer-events-none">
        <h2 class="text-primary font-medium tracking-widest uppercase mb-2 text-xs md:text-sm md:mb-4">Career Path</h2>
        <p class="font-display text-4xl md:text-6xl font-bold">
          Professional <span class="text-transparent bg-clip-text bg-linear-to-r from-white to-gray-500">Journey</span>
        </p>
      </div>
      
      <!-- The Moving Train of Cards -->
      <div class="cards-train flex items-center train-padding gap-[5vw] md:gap-[10vw] w-max">
        {experiences.map((exp, index) => (
          <div class="experience-card relative shrink-0 w-[90vw] md:w-[60vw] max-w-[800px] p-6 md:p-12 rounded-3xl bg-gray-900/80 border border-white/10 shadow-2xl">
            
            <!-- Glow Effect -->
            <div class="absolute -right-20 -top-20 w-64 h-64 bg-primary/10 rounded-full blur-3xl opacity-0 card-glow"></div>

            <div class="relative z-10 flex flex-col gap-6">
              <div class="flex items-center justify-between">
                <span class="px-4 py-2 text-sm font-bold tracking-wider text-primary uppercase bg-primary/10 rounded-full border border-primary/20">
                  {exp.period}
                </span>
                <span class="text-8xl font-display font-bold text-white/5 absolute -top-10 right-0 pointer-events-none">
                  0{index + 1}
                </span>
              </div>
              
              <div>
                <h3 class="text-3xl md:text-6xl font-display font-bold mb-2 text-white">{exp.role}</h3>
                <p class="text-xl md:text-2xl text-secondary font-light">{exp.company}</p>
              </div>

              <p class="text-gray-300 text-lg md:text-xl leading-relaxed max-w-3xl">
                {exp.description}
              </p>

              <!-- Tech Stack -->
              <div class="flex flex-wrap gap-3 mt-4">
                {exp.technologies.map(tech => (
                  <span class="px-4 py-2 text-sm bg-black/30 text-gray-400 rounded-lg border border-white/5">
                    {tech}
                  </span>
                ))}
              </div>
            </div>
          </div>
        ))}
      </div>
  </div>
</section>

<script>
  import { gsap } from "gsap";
  import { ScrollTrigger } from "gsap/ScrollTrigger";

  gsap.registerPlugin(ScrollTrigger);

  function initExperience() {
    const container = document.querySelector('.scroll-container');
    const train = document.querySelector('.cards-train');
    
    if (!container || !train) return;

    const cards = gsap.utils.toArray('.experience-card');
    
    // Cache card data to avoid layout thrashing during scroll
    let cardMetrics = cards.map((card: any) => ({
      element: card,
      glow: card.querySelector('.card-glow'),
      offsetLeft: 0,
      width: 0
    }));

    const updateMetrics = () => {
      // Refresh calculations on resize/init
      cardMetrics.forEach(metric => {
        const rect = metric.element.getBoundingClientRect();
        // We only care about relative position in the train? 
        // No, we need screen position. But screen position changes with scroll.
        // Better strategy: Calculate center relative to the TRAIN, then Apply scroll offset.
        // Actually, for simplicity and performance, we can just read `offsetBound` relative to train?
        // Let's stick to getBoundingClientRect BUT only if needed, OR optimize.
        
        // BETTER OPTIMIZATION: 
        // The `getBoundingClientRect` inside onUpdate forces a reflow strictly because we are reading layout.
        // However, GSAP's `onUpdate` runs on every frame.
        // On Mac, high-DPI + high-refresh rate + blur effects = lag.
        // We can keep the logic simple but ensure we are not triggering layout thrashing by separating reads and writes.
        // But the best fix for "laggy on Mac" is often simply `will-change`.
        // Let's rely on `will-change` first, and if that fails, do the complex caching.
        // Actually, the user asked to solve lag.
        // Caching `offsetLeft` (static in the train) is safer.
        metric.offsetLeft = metric.element.offsetLeft;
        metric.width = metric.element.offsetWidth;
      });
    };

    // Calculate total scroll distance
    const getScrollAmount = () => {
      return -(train.scrollWidth - window.innerWidth);
    };

    const tween = gsap.to(train, {
      x: getScrollAmount,
      ease: "none",
      onStart: () => {
        // Prepare layers for high performance
        gsap.set('.experience-card', { willChange: "transform, opacity" });
      },
      scrollTrigger: {
        trigger: container,
        pin: true,
        start: "top top",
        scrub: 1, // Smoothing helps mask jitter
        end: () => "+=" + (train.scrollWidth - window.innerWidth), 
        invalidateOnRefresh: true,
        onRefresh: () => updateMetrics(),
        onUpdate: (self) => {
          // Optimization: Calculate current visual position without thrashing
          // currentScrollX is roughly: self.progress * maxScroll
          // But strict `getBoundingClientRect` is easiest. 
          // To fix lag, let's just THROTTLE the visual updates or simplfy the effect?
          // No, let's try the cached offset method.
          
          const progress = self.progress;
          const maxScroll = train.scrollWidth - window.innerWidth;
          const currentTranslate = progress * maxScroll; // This is positive value of how much we moved left
          
          const centerScreen = window.innerWidth / 2;
          
          cardMetrics.forEach((metric: any) => {
            // Calculate screen X based on train's transform
            // Train X moves from 0 to -maxScroll
            const trainX = -currentTranslate;
            const cardScreenX = trainX + metric.offsetLeft + (metric.width / 2);
            
            const distFromCenter = Math.abs(centerScreen - cardScreenX);
            
            // Calculate intensity (0 to 1) based on distance
            // Narrower range (0.5) creates a sharper "spotlight" effect
            let intensity = 1 - (distFromCenter / (window.innerWidth * 0.5));
            intensity = Math.max(0, Math.min(intensity, 1));
            
            const scale = 0.9 + (0.1 * intensity);
            const opacity = 0.4 + (0.6 * intensity);
            
            gsap.set(metric.element, { 
              scale: scale, 
              opacity: opacity,
              zIndex: distFromCenter < 200 ? 10 : 1,
              overwrite: 'auto' // ensure clean overwrites
            });
            
            if (metric.glow) {
              gsap.set(metric.glow, { opacity: intensity * 0.5 });
            }
          });
        }
      }
    });
    
    // Initial metric calc
    updateMetrics();
  }

  // Defer slightly to ensure layout is ready
  // GSAP handles resize automatically via ScrollTrigger.refresh()
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initExperience);
  } else {
    initExperience();
  }
</script>

<style>
  .experience-card {
    /* Base styles */
  }

  .train-padding {
    padding-left: 5vw;
    padding-right: 5vw;
  }

  @media (min-width: 768px) {
    .train-padding {
      /* 
        Center logic: 50vw (half screen) - half card width.
        Card width is 60vw but maxes out at 800px.
        Using min() handles both cases specifically for large screens.
      */
      padding-left: calc(50vw - min(60vw, 800px) / 2);
      padding-right: calc(50vw - min(60vw, 800px) / 2);
    }
  }
</style>
